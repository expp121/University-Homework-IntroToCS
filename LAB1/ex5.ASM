	CLO
	JMP START
	DB 0 ; 		i1 [3]
	DB 0 ; 		i2 [4]
	DB 0 ; 		r  [5]

START:
	IN 00         ;	GET INPUT FROM KEYBOARD FOR i1
	SUB AL, 30    ; CONVERT THE ASCII VALUE OF THE NUMBER TO NORMAL NUMBER
	MOV [03] , AL ;	SAVE IT 
	
	IN 00 ;		GET INPUT FROM KEYBOARD FOR i2
	SUB AL, 30    ; CONVERT THE ASCII VALUE OF THE NUMBER TO NORMAL NUMBER
	MOV [04] , AL ; SAVE IT

	MOV AL , [04] ; AL = 4
	PUSH AL ; 	PUSHING  4 INTO STACK -> STACK[0]
	MOV AL , [03] ; AL = 8
	PUSH AL ; 	PUSHING  8 INTO STACK -> STACK[1]
	CALL 40 ; 	CALLING GCD, PUSHING  11 INTO STACK -> STACK[2]
	POP AL ; 	AL = STACK[1]
	ADD AL , 30 ; 	AL = AL + 30
	MOV [C0] , AL

GCD: 
	ORG 40 ; 	WRITE FUNCTION'S INSTRUCTION FROM ADDRESS 40
	POP CL ; 	ADDRESS TO RETURN TO START, CL = 11 <- STACK[2]
	MOV [B0], CL ; 	SAVING THE FUNCTION'S RETURN ADDRESS JUST IN CASE
	POP CL ; 	GET THE FIRST GIVEN ARGUMENT FROM THE FUNCTION INTO CL  //i1, CL = 8 <- STACK[1]
	POP DL ; 	GET THE SECONG GIVEN ARGUMENT FROM THE FUNCTION INTO DL //i2, DL = 4 <- STACK[0]
LOOP:	
	CMP DL , 0 ; 	IS DL == 0 ?, IF SO, SET Z TO 1
	MOD CL, DL ; 	CL = CL % DL
	MOV [05], CL ; 	SAVE CL % DL INTO ADDRESS [05] OR VARIABLE r
	
	PUSH DL ;
	POP CL ;  	MOV CL , DL
	
	MOV DL, [05] ;  DL = r([05])
	JNZ LOOP ; 	JUMP TO LOOP IF Z IS 1
	PUSH CL ;	PUSHING CL INTO STACK -> STACK[0]
	MOV AL , [B0] ; AL = [B0]
	PUSH AL ; 	PUSHING AL INTO STACK -> STACK[1]
	RET

	END
			