	CLO
	JMP START
	DB 0 	      ; i1 [3]
	DB 0 	      ; i2 [4]
	DB 0          ; r  [5]

START:
	CALL A0	      ; CALL THE GETINPUT FUNCTION
	CALL 70	      ; CALL THE NORMALIZE FUNCTION
	PUSH CL
	POP AL
	MOV [03] , AL ;	SAVE IT 
	
	CALL A0	      ; CALL THE GETINPUT FUNCTION
	CALL 70	      ; CALL THE NORMALIZE FUNCTION
	PUSH CL
	POP AL
	MOV [04] , AL ;	SAVE IT 

	POP DL	      ; JUST EMPIES THE STACK
	POP DL	      ; JUST EMPIES THE STACK
	PUSH AL       ; PUSH THE FIRST NUMBER FOR THE GCD FUNCTION INTO THE STACK
	MOV AL, [03]  ; GETS THE OTHER NUMBER
	PUSH AL	      ; PUSHES THE SECOND NUMBER FOR THE GCD FUNCTION INTO THE STACK
	CALL 40	      ; CALL THE GCD FUNCTION
	POP AL	      ; GETS THE RESULT FROM THE FUNCTION

	ADD AL , 30   ; CONVERTS THE RESULT INTO AN ASCII CHARACTER
	MOV [C0] , AL ; DISPLAYS THE RESULT


GETINPUT:
	ORG A0	      ; THE FUNCTION'S INSTRUCTIONS WILL BEGEIN FROM ADDRESS a0
	POP CL	      ; GET THE FUNCTION RETURN ADDRESS INTO CL

	IN 00	      ; GETS INPUT FROM THE KEYBOARD AND STORES IT IN REGISTER al
	SUB AL, 30    ; SUBTRACT 30 FROM AL TO HELP NORMALIZE IT
	MOV [B0], CL  ; SAVING THE FUNCTION'S RETURN ADDRESS JUST IN CASE
	PUSH AL	      ; PUSH al TO THE STACK, THAT WAY YOU CAN USE IT LIKE A RETURN FROM THE FUNCTION
	PUSH CL	      ; PUSH cl TO THE STACK, SO THE FUCNTION KNOWS WHERE TO RETURN
	RET	          ; RETURN TO WHERE THE FUNCTION WAS CALLED

NORMALIZE:
	ORG 70	      ; THE FUNCTION'S INSTRUCTIONS WILL BEGEIN FROM ADDRESS 70
	MOV DL, 27    ; MOVE 27 INTO DL, IT WILL BE USED TO CONVERT SMALL LETTERS INTO NUMBERS
	POP CL	      ; GET THE FUNCTION RETURN ADDRESS INTO CL
	MOV [B0], CL  ; SAVING THE FUNCTION'S RETURN ADDRESS JUST IN CASE
	POP CL 	      ; GET THE GIVEN ARGUMENT TO THE FUNCTION INTO CL(THE NUMBER) 	
	CMP DL, CL    ; IF THE LETTER IS SMALL JUMP TO SUB27 ELSE JUMP TO SUB7
	JS SUB27
	JNS SUB7
SUB27:
	SUB CL, DL    ; SUBTRACT 27 FROM CL
	JMP FUNCEND   ; GO TO FUNCTUION END
SUB7:

	CMP CL, 0A    ; COMPARE IF THE VALUE IN CL IS LESS THAN 10, IF SO JUMP, ELSE SUBTRACT 7 FROM THE NUMBER TO BE CONVERTED IN IN DIVISABLE FORM
	JS FUNCEND
	SUB CL, 7

FUNCEND:
	MOV DL, [B0]  ; GETS THE FUNCTION'S RETURN ADDRESS INTO DL
	PUSH CL	      ; PUSHES THE CONVERTED NUMBER INTO THE STACK
	PUSH DL	      ; PUSHES THE RETRUN ADDRESS OF THE FUNCTION INTO THE STACK
	RET	      	  ; RETURNS TO THE ROW WHICH THE FUNCTION WAS CALLED


GCD: 
	ORG 40 	      ; WRITE FUNCTION'S INSTRUCTION FROM ADDRESS 40
	POP CL        ; ADDRESS TO RETURN TO START, CL = 11 <- STACK[2]
	MOV [B0], CL  ; SAVING THE FUNCTION'S RETURN ADDRESS JUST IN CASE
	POP CL        ; GET THE FIRST GIVEN ARGUMENT FROM THE FUNCTION INTO CL  //i1, CL = 8 <- STACK[1]
	POP DL        ; GET THE SECONG GIVEN ARGUMENT FROM THE FUNCTION INTO DL //i2, DL = 4 <- STACK[0]
LOOP:	
	CMP DL , 0    ; IS DL == 0 ?, IF SO, SET Z TO 1
	MOD CL, DL    ; CL = CL % DL
	MOV [05], CL  ; SAVE CL % DL INTO ADDRESS [05] OR VARIABLE r
	
	PUSH DL
	POP CL 	      ; MOV CL , DL
	
	MOV DL, [05]  ; DL = r([05])
	JNZ LOOP      ; JUMP TO LOOP IF Z IS 1
	PUSH CL       ;	PUSHING CL INTO STACK -> STACK[0]
	MOV AL , [B0] ; AL = [B0]
	PUSH AL       ; PUSHING AL INTO STACK -> STACK[1]
	RET

	END
			